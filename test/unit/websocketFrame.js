#!/usr/bin/env node
"use strict";

var _utils = require("../../lib/utils");

var libutils_utilsjs = _interopRequireWildcard(_utils);

var _WebSocketFrame = require("../../lib/WebSocketFrame");

var _WebSocketFrame2 = _interopRequireDefault(_WebSocketFrame);

var _bufferEqual = require("buffer-equal");

var _bufferEqual2 = _interopRequireDefault(_bufferEqual);

var _tape = require("tape");

var _tape2 = _interopRequireDefault(_tape);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var test = _tape2.default;
var bufferEqual = _bufferEqual2.default;
var WebSocketFrame = _WebSocketFrame2.default;
var utils = libutils_utilsjs;
var bufferAllocUnsafe = utils.bufferAllocUnsafe;
var bufferFromString = utils.bufferFromString;

test('Serializing a WebSocket Frame with no data', function (t) {
  t.plan(2);

  // WebSocketFrame uses a per-connection buffer for the mask bytes
  // and the frame header to avoid allocating tons of small chunks of RAM.
  var maskBytesBuffer = bufferAllocUnsafe(4);
  var frameHeaderBuffer = bufferAllocUnsafe(10);

  var frameBytes;
  var frame = new WebSocketFrame(maskBytesBuffer, frameHeaderBuffer, {});
  frame.fin = true;
  frame.mask = true;
  frame.opcode = 0x09; // WebSocketFrame.PING
  t.doesNotThrow(function () {
    frameBytes = frame.toBuffer(true);
  }, 'should not throw an error');

  t.assert(bufferEqual(frameBytes, bufferFromString('898000000000', 'hex')), 'Generated bytes should be correct');

  t.end();
});